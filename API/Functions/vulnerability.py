# -*- coding: utf-8 -*-
# Tachiu Lam
# lintechao@yingzi.com
# 2020/6/11 10:15
from VulnManage.models import Vulnerability_scan, Vulnerability
from AssetManage.models import Asset
import time


class VulnerabilityManage:
    """通用漏洞类，统一处理漏洞状态、漏洞去重"""

    @staticmethod
    def get_vuln_id(v_type='1'):
        """获取id，用于生成vuln_id"""
        try:
            if v_type == '1':
                v_num_id = Vulnerability_scan.objects.latest('id').id
            elif v_type =='2':
                v_num_id = Vulnerability.objects.latest('id').id
        except Exception as error:
            print(error)
            v_num_id = 0
        return v_num_id

    @staticmethod
    def status(name, v_num_id, num_id=None, v_type='1'):
        """
        判断漏洞是否已存在，返回漏洞状态等信息；使用资产和漏洞名称两个字段判断
        :param num_id:  资产id
        :param name:  漏洞名
        :param v_type:  区分漏洞库和漏洞列表接口
        :param v_num_id:  漏洞表id，用于生成漏洞id字符串
        :return: {'exits': True, 'fix_status': vuln.fix_status, 'asset': asset}
                {'exits': False, 'fix_status': '2', 'v_type': asset_type_name, 'v_id': v_id, 'asset': asset}
        """
        if v_type == '1':
            # 获得资产字段，进行漏洞信息关联
            asset = Asset.objects.get(id=num_id)
            asset_type_id = asset.asset_type_id
            asset_type_name = asset.asset_type.name  # 漏洞类型，关联到资产类型

            # 根据漏洞名、所属资产、漏洞状态判断漏洞是否存在
            res = Vulnerability_scan.objects.filter(vuln_name=name, vuln_asset=asset)
            if res:
                vuln = Vulnerability_scan.objects.get(vuln_name=name, vuln_asset=asset)
                if vuln.fix_status == '1':  # 漏洞重复且状态为已修复时
                    vuln.fix_status = '3'  # 置为 漏洞复现
                elif vuln.fix_status != '0' and vuln.leave == '0':      # 漏洞等级为信息且漏洞状态不为“已忽略”
                    vuln.fix_status = '0'  # 置为 已忽略
                return {'exits': True, 'fix_status': vuln.fix_status, 'asset': asset}  # 漏洞已存在时，返回信息
            else:
                v_id = str(asset_type_id) + time.strftime('%Y%m%d', time.localtime(time.time())) + str(v_num_id)
                return {'exits': False, 'fix_status': '2', 'v_type': asset_type_name, 'v_id': v_id, 'asset': asset}
        elif v_type =='2':
            # 根据漏洞名判断漏洞是否存在
            res = Vulnerability.objects.filter(vuln_name=name)
            if res:
                return {'exits': True}  # 漏洞已存在时，返回信息
            else:
                v_id = time.strftime('%Y%m%d', time.localtime(time.time())) + str(v_num_id)
                return {'exits': False, 'v_id': v_id}

    @staticmethod
    def update_or_create(v_dict, exits, v_type='1'):
        """
        根据漏洞是否存在，创建或更新漏洞信息
        :param v_dict:  漏洞信息字典，包含所有漏洞数据
        :param exits:   漏洞是否存在， True| False
        :return: {'result': '漏洞导入成功'}
                {'result': '漏洞更新成功'}
                {'result': error}
        """
        try:
            if v_type == '1':
                if not exits:  # 若为新漏洞
                    Vulnerability_scan.objects.create(
                        vuln_name=v_dict['name'],
                        vuln_asset=v_dict['asset'],
                        fix_status=v_dict['fix_status'],
                        vuln_id=v_dict['v_id'],
                        cve_name=v_dict['cve'],
                        leave=v_dict['level'],
                        vuln_type=v_dict['v_type'],
                        introduce=v_dict['introduce'],
                        vuln_info=v_dict['return'],
                        scopen=v_dict['port'],
                        fix=v_dict['fix'],
                    )
                    return {'result': '漏洞导入成功'}
                else:
                    # 使用get操作是为了有auto_now属性的字段可以更新，如"更新时间"
                    res = Vulnerability_scan.objects.get(
                        vuln_name=v_dict['name'],  # get操作，使用漏洞名称和漏洞归属资产进行筛选，使用其他变化字段会导致修改后新增资产，无法更新资产
                        vuln_asset=v_dict['asset'],
                    )
                    # 若已存在，更新漏洞状态，同时刷新更新时间
                    res.fix_status = v_dict['fix_status']
                    res.save()
                    return {'result': '漏洞更新成功'}
            elif v_type == '2':
                if not exits:  # 若为新漏洞
                    Vulnerability.objects.create(
                        vuln_name=v_dict['name'],
                        vuln_id=v_dict['v_id'],
                        cve_name=v_dict['cve'],
                        leave=v_dict['level'],
                        introduce=v_dict['introduce'],
                        note=v_dict['return'],
                        fix=v_dict['fix'],
                    )
                    return {'result': '成功导入漏洞库'}
                else:
                    # 使用get操作是为了有auto_now属性的字段可以更新，如"更新时间"
                    res = Vulnerability.objects.get(
                        vuln_name=v_dict['name'],  # get操作，使用漏洞名称和漏洞归属资产进行筛选，使用其他变化字段会导致修改后新增资产，无法更新资产
                    )
                    # 若已存在，更新漏洞危险登记，同时刷新更新时间
                    res.leave = v_dict['level']
                    res.save()
                    return {'result': '漏洞库更新成功'}
        except Exception as error:
            return {'result': error}
